import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { ConfigManager } from '../utils/config';
import { GitignoreManager } from '../utils/gitignoreManager';
import { QraftPatterns } from '../utils/qraftPatterns';
import { GitignoreCommand, GitignoreCommandOptions } from './gitignore';

// Mock dependencies
jest.mock('../utils/gitignoreManager');
jest.mock('../utils/qraftPatterns');
jest.mock('../utils/config');

const MockedGitignoreManager = GitignoreManager as jest.MockedClass<typeof GitignoreManager>;
const MockedQraftPatterns = QraftPatterns as jest.MockedClass<typeof QraftPatterns>;
const MockedConfigManager = ConfigManager as jest.MockedClass<typeof ConfigManager>;

describe('GitignoreCommand', () => {
  let gitignoreCommand: GitignoreCommand;
  let mockGitignoreManager: jest.Mocked<GitignoreManager>;
  let mockQraftPatterns: jest.Mocked<QraftPatterns>;
  let mockConfigManager: jest.Mocked<ConfigManager>;
  let tempDir: string;

  beforeEach(async () => {
    // Create temporary directory for tests
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gitignore-test-'));

    // Reset all mocks
    jest.clearAllMocks();

    // Create mock instances
    mockGitignoreManager = new MockedGitignoreManager() as jest.Mocked<GitignoreManager>;
    mockQraftPatterns = new MockedQraftPatterns() as jest.Mocked<QraftPatterns>;
    mockConfigManager = new MockedConfigManager() as jest.Mocked<ConfigManager>;

    // Setup default mock implementations
    setupDefaultMocks();

    // Create GitignoreCommand with mocked dependencies
    gitignoreCommand = new GitignoreCommand(
      mockGitignoreManager,
      mockQraftPatterns,
      mockConfigManager
    );
  });

  afterEach(async () => {
    // Clean up temporary directory
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  function setupDefaultMocks() {
    // GitignoreManager mocks
    mockGitignoreManager.getGitignorePath.mockImplementation((dir) => path.join(dir, '.gitignore'));
    mockGitignoreManager.exists.mockResolvedValue(false);
    mockGitignoreManager.read.mockResolvedValue('');
    mockGitignoreManager.validateTargetDirectory.mockResolvedValue(undefined);
    mockGitignoreManager.checkPermissions.mockResolvedValue({
      canWrite: true,
      fileExists: false,
      canCreate: true,
      fileWritable: false
    });
    mockGitignoreManager.filterDuplicatePatterns.mockImplementation((_content, patterns) => ({
      newPatterns: patterns,
      existingPatterns: []
    }));
    mockGitignoreManager.addPatterns.mockResolvedValue({
      success: true,
      created: true,
      modified: false,
      patternsAdded: ['.qraft/', '.qraftrc'],
      patternsSkipped: []
    });
    mockGitignoreManager.hasPattern.mockReturnValue(true);

    // QraftPatterns mocks
    mockQraftPatterns.getContextAwarePatterns.mockResolvedValue([
      {
        pattern: '.qraft/',
        category: 'LOCAL' as any,
        description: 'Qraft metadata directory',
        isStatic: true
      },
      {
        pattern: '.qraftrc',
        category: 'LOCAL' as any,
        description: 'Qraft configuration file',
        isStatic: true
      }
    ]);
    mockQraftPatterns.getStaticPatterns.mockReturnValue([
      {
        pattern: '.qraft/',
        category: 'LOCAL' as any,
        description: 'Qraft metadata directory',
        isStatic: true
      }
    ]);
    mockQraftPatterns.getAllPatterns.mockResolvedValue([
      {
        pattern: '.qraft/',
        category: 'LOCAL' as any,
        description: 'Qraft metadata directory',
        isStatic: true
      }
    ]);
    mockQraftPatterns.validateAndNormalizePatterns.mockImplementation((patterns) => ({
      valid: patterns,
      invalid: []
    }));
    mockQraftPatterns.getSectionTitle.mockReturnValue('Qraft Files');
    mockQraftPatterns.getSectionDescription.mockReturnValue('Generated by qraft gitignore command');

    // ConfigManager mocks
    mockConfigManager.getConfig.mockResolvedValue({
      defaultRegistry: 'test/registry',
      registries: {
        'test/registry': {
          name: 'test/registry',
          repository: 'test/registry'
        }
      },
      cache: {
        enabled: true,
        ttl: 3600,
        directory: '/tmp/qraft-cache'
      }
    });
  }

  describe('constructor', () => {
    it('should create GitignoreCommand with default dependencies', () => {
      const command = new GitignoreCommand();
      expect(command).toBeInstanceOf(GitignoreCommand);
    });

    it('should create GitignoreCommand with provided dependencies', () => {
      expect(gitignoreCommand).toBeInstanceOf(GitignoreCommand);
    });
  });

  describe('execute', () => {
    it('should execute successfully with default options', async () => {
      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(result.created).toBe(true);
      expect(result.patternsAdded).toEqual(['.qraft/', '.qraftrc']);
      expect(result.message).toContain('Created');
      expect(mockQraftPatterns.getContextAwarePatterns).toHaveBeenCalled();
      expect(mockGitignoreManager.addPatterns).toHaveBeenCalled();
    });

    it('should use provided directory option', async () => {
      const customDir = path.join(tempDir, 'custom');
      await fs.mkdir(customDir, { recursive: true });

      const options: GitignoreCommandOptions = {
        directory: customDir
      };

      await gitignoreCommand.execute(options);

      expect(mockQraftPatterns.getContextAwarePatterns).toHaveBeenCalledWith(customDir);
      expect(mockGitignoreManager.addPatterns).toHaveBeenCalledWith(
        customDir,
        expect.any(Array),
        expect.any(String),
        expect.any(String),
        expect.any(Object)
      );
    });

    it('should handle dry run mode', async () => {
      const options: GitignoreCommandOptions = {
        dryRun: true
      };

      const result = await gitignoreCommand.execute(options);

      expect(result.success).toBe(true);
      expect(result.message).toContain('Dry run completed');
      expect(mockGitignoreManager.addPatterns).not.toHaveBeenCalled();
    });

    it('should handle force mode', async () => {
      const options: GitignoreCommandOptions = {
        force: true
      };

      await gitignoreCommand.execute(options);

      expect(mockGitignoreManager.addPatterns).toHaveBeenCalledWith(
        expect.any(String),
        expect.any(Array),
        expect.any(String),
        expect.any(String),
        expect.objectContaining({ force: true })
      );
    });

    it('should handle verbose mode', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸš€ Qraft Gitignore Command'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ“‹ Pattern Analysis'));

      consoleSpy.mockRestore();
    });

    it('should handle no valid patterns', async () => {
      mockQraftPatterns.getContextAwarePatterns.mockResolvedValue([]);

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(result.message).toContain('No valid qraft patterns to add');
      expect(mockGitignoreManager.addPatterns).not.toHaveBeenCalled();
    });

    it('should handle pattern validation errors', async () => {
      mockQraftPatterns.validateAndNormalizePatterns.mockReturnValue({
        valid: ['.qraft/'],
        invalid: [
          {
            pattern: 'invalid-pattern',
            errors: ['Pattern contains invalid characters']
          }
        ]
      });

      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      await gitignoreCommand.execute();

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Some patterns were invalid'));

      consoleSpy.mockRestore();
    });
  });

  describe('error handling', () => {
    it('should handle prerequisite validation failure', async () => {
      const options: GitignoreCommandOptions = {
        directory: ''
      };

      const result = await gitignoreCommand.execute(options);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Target directory cannot be empty');
    });

    it('should handle pattern loading errors with fallback', async () => {
      mockQraftPatterns.getContextAwarePatterns.mockRejectedValue(new Error('Pattern loading failed'));

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(mockQraftPatterns.getStaticPatterns).toHaveBeenCalled();
    });

    it('should handle complete pattern loading failure', async () => {
      mockQraftPatterns.getContextAwarePatterns.mockRejectedValue(new Error('Pattern loading failed'));
      mockQraftPatterns.getStaticPatterns.mockImplementation(() => {
        throw new Error('Static patterns failed');
      });

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(false);
      expect(result.error).toContain('Static patterns failed');
    });

    it('should handle gitignore manager errors', async () => {
      mockGitignoreManager.addPatterns.mockRejectedValue(new Error('Permission denied'));

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(false);
      expect(result.message).toContain('Permission denied');
    });

    it('should provide user-friendly error messages', async () => {
      mockGitignoreManager.addPatterns.mockRejectedValue(new Error('EACCES: permission denied'));

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(false);
      expect(result.message).toContain('Permission denied');
    });

    it('should handle unexpected errors', async () => {
      mockQraftPatterns.getContextAwarePatterns.mockRejectedValue('Unexpected error');
      mockQraftPatterns.getStaticPatterns.mockImplementation(() => {
        throw new Error('Unexpected error');
      });

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(false);
      expect(result.error).toBe('Unexpected error');
    });
  });

  describe('permission handling', () => {
    it('should handle file creation confirmation', async () => {
      mockGitignoreManager.exists.mockResolvedValue(false);

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(mockGitignoreManager.validateTargetDirectory).toHaveBeenCalled();
    });

    it('should handle existing file modification', async () => {
      mockGitignoreManager.exists.mockResolvedValue(true);
      mockGitignoreManager.read.mockResolvedValue('# Existing content\n');
      mockGitignoreManager.addPatterns.mockResolvedValue({
        success: true,
        created: false,
        modified: true,
        patternsAdded: ['.qraft/'],
        patternsSkipped: ['.qraftrc']
      });

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(result.modified).toBe(true);
    });

    it('should skip confirmations with force flag', async () => {
      const options: GitignoreCommandOptions = {
        force: true,
        verbose: true
      };

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Force mode enabled'));

      consoleSpy.mockRestore();
    });
  });

  describe('dry run functionality', () => {
    it('should show detailed dry run output', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        dryRun: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('DRY RUN MODE'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Target directory'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('File preview'));

      consoleSpy.mockRestore();
    });

    it('should handle dry run with existing file', async () => {
      mockGitignoreManager.exists.mockResolvedValue(true);
      mockGitignoreManager.read.mockResolvedValue('# Existing content\n*.log\n');
      mockGitignoreManager.filterDuplicatePatterns.mockReturnValue({
        newPatterns: ['.qraft/'],
        existingPatterns: ['.qraftrc']
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        dryRun: true
      };

      const result = await gitignoreCommand.execute(options);

      expect(result.success).toBe(true);
      expect(result.patternsAdded).toEqual(['.qraft/']);
      expect(result.patternsSkipped).toEqual(['.qraftrc']);
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Would add to existing file'));

      consoleSpy.mockRestore();
    });

    it('should show no changes needed in dry run', async () => {
      mockGitignoreManager.exists.mockResolvedValue(true);
      mockGitignoreManager.filterDuplicatePatterns.mockReturnValue({
        newPatterns: [],
        existingPatterns: ['.qraft/', '.qraftrc']
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        dryRun: true
      };

      const result = await gitignoreCommand.execute(options);

      expect(result.success).toBe(true);
      expect(result.patternsAdded).toEqual([]);
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('No new patterns to add'));

      consoleSpy.mockRestore();
    });
  });

  describe('verbose output', () => {
    it('should display startup information', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true,
        force: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸš€ Qraft Gitignore Command'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Options: force, verbose'));

      consoleSpy.mockRestore();
    });

    it('should display pattern analysis', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ“‹ Pattern Analysis'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('LOCAL: 2 patterns'));

      consoleSpy.mockRestore();
    });

    it('should display validation results', async () => {
      mockQraftPatterns.validateAndNormalizePatterns.mockReturnValue({
        valid: ['.qraft/'],
        invalid: [
          {
            pattern: 'invalid',
            errors: ['Invalid pattern']
          }
        ]
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ” Pattern Validation Results'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Valid patterns: 1'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Invalid patterns: 1'));

      consoleSpy.mockRestore();
    });

    it('should display operation results', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ“Š Operation Results'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('File created'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Patterns added: 2'));

      consoleSpy.mockRestore();
    });

    it('should display post-operation validation', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      // Mock file to exist after operation for post-validation
      mockGitignoreManager.exists.mockResolvedValueOnce(false).mockResolvedValue(true);
      mockGitignoreManager.read.mockResolvedValue('# Qraft Files\n.qraft/\n.qraftrc');

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ” Post-Operation Validation'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('File exists: âœ…'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Patterns verified: âœ…'));

      consoleSpy.mockRestore();
    });
  });

  describe('pattern context building', () => {
    it('should analyze pattern context correctly', async () => {
      // Set up patterns that will actually be processed
      mockQraftPatterns.getContextAwarePatterns.mockResolvedValue([
        {
          pattern: '.qraft/',
          category: 'LOCAL' as any,
          description: 'Qraft metadata directory',
          isStatic: true
        },
        {
          pattern: 'cache/',
          category: 'CONFIG' as any,
          description: 'Cache directory',
          isStatic: false
        }
      ]);
      mockQraftPatterns.getAllPatterns.mockResolvedValue([
        {
          pattern: '.qraft/',
          category: 'LOCAL' as any,
          description: 'Qraft metadata directory',
          isStatic: true
        },
        {
          pattern: 'cache/',
          category: 'CONFIG' as any,
          description: 'Cache directory',
          isStatic: false
        }
      ]);
      mockQraftPatterns.validateAndNormalizePatterns.mockImplementation((patterns) => ({
        valid: patterns,
        invalid: []
      }));

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      await gitignoreCommand.execute(options);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ“‹ Pattern Context Analysis'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Static patterns: 1'));
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Dynamic patterns: 1'));

      consoleSpy.mockRestore();
    });
  });

  describe('error message formatting', () => {
    it('should format permission errors correctly', async () => {
      const error = new Error('EACCES: permission denied');
      const result = await gitignoreCommand['getUserFriendlyErrorMessage'](error, 'during file creation');

      expect(result).toContain('Permission denied during file creation');
      expect(result).toContain("don't have the necessary permissions");
    });

    it('should format file not found errors correctly', async () => {
      const error = new Error('ENOENT: no such file or directory');
      const result = await gitignoreCommand['getUserFriendlyErrorMessage'](error, 'while accessing directory');

      expect(result).toContain('Directory or file not found while accessing directory');
      expect(result).toContain('check that the path exists');
    });

    it('should format disk space errors correctly', async () => {
      const error = new Error('ENOSPC: no space left on device');
      const result = await gitignoreCommand['getUserFriendlyErrorMessage'](error, 'while writing file');

      expect(result).toContain('Insufficient disk space while writing file');
      expect(result).toContain('free up some space');
    });

    it('should format configuration errors correctly', async () => {
      const error = new Error('Configuration file is corrupted');
      const result = await gitignoreCommand['getUserFriendlyErrorMessage'](error, 'during initialization');

      expect(result).toContain('Configuration error during initialization');
      expect(result).toContain('issue with your qraft settings');
    });

    it('should handle unknown errors', async () => {
      const error = new Error('Some unknown error');
      const result = await gitignoreCommand['getUserFriendlyErrorMessage'](error, 'during operation');

      expect(result).toContain('An error occurred during operation: Some unknown error');
    });

    it('should handle non-Error objects', async () => {
      const error = 'String error';
      const result = await gitignoreCommand['getUserFriendlyErrorMessage'](error, 'during operation');

      expect(result).toContain('An unexpected error occurred during operation');
    });
  });

  describe('integration scenarios', () => {
    it('should handle complete workflow with existing file', async () => {
      // Setup existing file scenario
      mockGitignoreManager.exists.mockResolvedValue(true);
      mockGitignoreManager.read.mockResolvedValue('# Existing content\n*.log\n');
      mockGitignoreManager.filterDuplicatePatterns.mockReturnValue({
        newPatterns: ['.qraft/'],
        existingPatterns: ['.qraftrc']
      });
      mockGitignoreManager.addPatterns.mockResolvedValue({
        success: true,
        created: false,
        modified: true,
        patternsAdded: ['.qraft/'],
        patternsSkipped: ['.qraftrc']
      });

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(result.created).toBe(false);
      expect(result.modified).toBe(true);
      expect(result.patternsAdded).toEqual(['.qraft/']);
      expect(result.patternsSkipped).toEqual(['.qraftrc']);
      expect(result.message).toContain('Updated');
    });

    it('should handle workflow with no changes needed', async () => {
      mockGitignoreManager.exists.mockResolvedValue(true);
      mockGitignoreManager.filterDuplicatePatterns.mockReturnValue({
        newPatterns: [],
        existingPatterns: ['.qraft/', '.qraftrc']
      });
      mockGitignoreManager.addPatterns.mockResolvedValue({
        success: true,
        created: false,
        modified: false,
        patternsAdded: [],
        patternsSkipped: ['.qraft/', '.qraftrc']
      });

      const result = await gitignoreCommand.execute();

      expect(result.success).toBe(true);
      expect(result.patternsAdded).toEqual([]);
      expect(result.patternsSkipped).toEqual(['.qraft/', '.qraftrc']);
      expect(result.message).toContain('already exist');
    });

    it('should handle graceful degradation when config fails', async () => {
      mockConfigManager.getConfig.mockRejectedValue(new Error('Config not found'));

      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      const options: GitignoreCommandOptions = {
        verbose: true
      };

      const result = await gitignoreCommand.execute(options);

      expect(result.success).toBe(true);
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Could not load qraft configuration'));

      consoleSpy.mockRestore();
    });
  });
});

describe('createGitignoreCommand', () => {
  let originalExit: typeof process.exit;
  let exitSpy: jest.SpyInstance;

  beforeEach(() => {
    // Mock process.exit to prevent tests from actually exiting
    originalExit = process.exit;
    exitSpy = jest.spyOn(process, 'exit').mockImplementation(() => {
      throw new Error('process.exit called');
    });
  });

  afterEach(() => {
    // Restore original process.exit
    process.exit = originalExit;
    exitSpy.mockRestore();
  });

  it('should create a command with correct configuration', () => {
    const { createGitignoreCommand } = require('./gitignore');
    const command = createGitignoreCommand();

    expect(command.name()).toBe('gitignore');
    expect(command.description()).toContain('Add qraft-specific patterns');
  });

  it('should have all required options', () => {
    const { createGitignoreCommand } = require('./gitignore');
    const command = createGitignoreCommand();

    const options = command.options;
    const optionFlags = options.map((opt: any) => opt.flags);

    expect(optionFlags).toContain('-d, --dry-run');
    expect(optionFlags).toContain('-f, --force');
    expect(optionFlags).toContain('-v, --verbose');
    expect(optionFlags).toContain('--directory <path>');
  });
});

describe('validateCommandOptions', () => {
  it('should validate valid options', () => {
    const { validateCommandOptions } = require('./gitignore');

    const options = {
      verbose: true,
      directory: '/valid/path'
    };

    const result = validateCommandOptions(options);
    expect(result.valid).toBe(true);
  });

  it('should reject conflicting dry-run and force options', () => {
    const { validateCommandOptions } = require('./gitignore');

    const options = {
      dryRun: true,
      force: true
    };

    const result = validateCommandOptions(options);
    expect(result.valid).toBe(false);
    expect(result.error).toContain('cannot be used together');
  });

  it('should reject empty directory path', () => {
    const { validateCommandOptions } = require('./gitignore');

    const options = {
      directory: ''
    };

    const result = validateCommandOptions(options);
    expect(result.valid).toBe(false);
    expect(result.error).toContain('must be a valid path');
  });

  it('should reject relative paths with .. without force', () => {
    const { validateCommandOptions } = require('./gitignore');

    const options = {
      directory: '../dangerous/path'
    };

    const result = validateCommandOptions(options);
    expect(result.valid).toBe(false);
    expect(result.error).toContain('not allowed');
  });

  it('should allow relative paths with .. when force is enabled', () => {
    const { validateCommandOptions } = require('./gitignore');

    const options = {
      directory: '../path',
      force: true
    };

    const result = validateCommandOptions(options);
    expect(result.valid).toBe(true);
  });
});

describe('handleCommandFailure', () => {
  let consoleErrorSpy: jest.SpyInstance;
  let exitSpy: jest.SpyInstance;

  beforeEach(() => {
    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    exitSpy = jest.spyOn(process, 'exit').mockImplementation(() => {
      throw new Error('process.exit called');
    });
  });

  afterEach(() => {
    consoleErrorSpy.mockRestore();
    exitSpy.mockRestore();
  });

  it('should handle permission errors with suggestions', () => {
    const { handleCommandFailure } = require('./gitignore');

    const result = {
      success: false,
      message: 'Permission denied',
      error: 'Permission denied: cannot write to directory'
    };

    const options = { verbose: true };

    expect(() => handleCommandFailure(result, options)).toThrow('process.exit called');

    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('âŒ Permission denied'));
    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ’¡ Permission issue suggestions'));
    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Try using --force'));
  });

  it('should handle file not found errors with suggestions', () => {
    const { handleCommandFailure } = require('./gitignore');

    const result = {
      success: false,
      message: 'Directory not found',
      error: 'ENOENT: no such file or directory'
    };

    const options = { verbose: false };

    expect(() => handleCommandFailure(result, options)).toThrow('process.exit called');

    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ’¡ Directory not found suggestions'));
    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Verify the target directory exists'));
  });

  it('should handle configuration errors with suggestions', () => {
    const { handleCommandFailure } = require('./gitignore');

    const result = {
      success: false,
      message: 'Configuration error',
      error: 'config file corrupted'
    };

    const options = { verbose: true };

    expect(() => handleCommandFailure(result, options)).toThrow('process.exit called');

    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ’¡ Configuration issue suggestions'));
    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('qraft config list'));
  });

  it('should provide general troubleshooting suggestions', () => {
    const { handleCommandFailure } = require('./gitignore');

    const result = {
      success: false,
      message: 'Unknown error',
      error: 'Something went wrong'
    };

    const options = { verbose: false };

    expect(() => handleCommandFailure(result, options)).toThrow('process.exit called');

    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('ðŸ’¡ General troubleshooting'));
    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Use --dry-run to test'));
    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Use --verbose for more detailed output'));
  });

  it('should show error details in verbose mode', () => {
    const { handleCommandFailure } = require('./gitignore');

    const result = {
      success: false,
      message: 'Operation failed',
      error: 'Detailed error information'
    };

    const options = { verbose: true };

    expect(() => handleCommandFailure(result, options)).toThrow('process.exit called');

    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Error details: Detailed error information'));
  });

  it('should not show error details in non-verbose mode', () => {
    const { handleCommandFailure } = require('./gitignore');

    const result = {
      success: false,
      message: 'Operation failed',
      error: 'Detailed error information'
    };

    const options = { verbose: false };

    expect(() => handleCommandFailure(result, options)).toThrow('process.exit called');

    expect(consoleErrorSpy).not.toHaveBeenCalledWith(expect.stringContaining('Error details:'));
  });
});
